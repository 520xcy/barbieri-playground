#!/usr/bin/python

"""Convert Point of Interest (PoI) from GARMIN GPX to Mercedes-Benz GPX
format used in newer COMMAND Online.

GARMIN GPX format that is used by its POI Loader uses
WaypointExtension from XML namespace
http://www.garmin.com/xmlschemas/GpxExtensions/v2 or
http://www.garmin.com/xmlschemas/GpxExtensions/v3
(http://www8.garmin.com/xmlschemas/GpxExtensions/v3/GpxExtensionsv3.xsd),
such as::

    <gpx xmlns='http://www.topografix.com/GPX/1/1'
        creator='SomeTool'
        version='1.1'
        xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
        xsi:schemaLocation='http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd'>
      <wpt lat="-1.23456" lon="-1.23456">
        <name>Some Waypoint</name>
        <link href="ExternalLink123"/>
        <sym>Radio Beacon</sym>
        <extensions>
          <gpxx:WaypointExtension
              xmlns:gpxx='http://www.garmin.com/xmlschemas/GpxExtensions/v2'
              xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
              xsi:schemaLocation='http://www.garmin.com/xmlschemas/GpxExtensions/v2 http://www.garmin.com/xmlschemas/GpxExtensions/v2/GpxExtensionsv2.xsd'>
            <gpxx:Proximity>150.0000000</gpxx:Proximity>
            <gpxx:DisplayMode>SymbolAndName</gpxx:DisplayMode>
          </gpxx:WaypointExtension>
        </extensions>
      </wpt>
    </gpx>

These elements in the "gpxx" namespace above (WaypointExtension,
Proximity, DisplayMode) are GARMIN extensions that are not supported
by Mercedes-Benz, which uses its own extension::

    <gpx xmlns='http://www.topografix.com/GPX/1/1'
        creator='SomeTool'
        version='1.1'
        xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
        xsi:schemaLocation='http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd'>
      <wpt lat="-1.23456" lon="-1.23456">
        <name>Some Waypoint</name>
        <link href="ExternalLink123"/>
        <sym>Radio Beacon</sym>
        <extensions>
          <gpxd:WptExtension
              xmlns:gpxd='http://www.daimler.com/DaimlerGPXExtensions/V2.7.2'>
            <gpxd:WptIconId IconId="16"></gpxd:WptIconId>
            <gpxd:POICategory Cat="Speed Camera"></gpxd:POICategory>
            <gpxd:Activity Active="true" Level="warning" Unit="second" Value="9"></gpxd:Activity>
            <gpxd:Presentation ShowOnMap="true"></gpxd:Presentation>
          </gpxd:WptExtension>
        </extensions>
      </wpt>
    </gpx>

This tool will then convert from GARMIN to Mercedes-Benz (DaimlerGPXExtensions).

.. note::

    DaimlerGPXExtensions provides no public schema, so it was inferred
    from data generated by the car COMMAND Online dashboard.
"""

__license__ = "BSD-3"

import logging
import fnmatch
import re
import xml.etree.ElementTree as ET

icon_name_to_id = {
    "default": "0",
    "internet": "1",
    "fishing": "2",
    "beach": "3",
    "camping": "4",
    "fireplace": "5",
    "tripod": "6",
    "heart": "7",
    "house": "8",
    "building": "9",
    "ski": "10",
    "restaurant": "11",
    "pin": "12",
    "car": "13",
    "bed": "14",
    "shopping": "15",
    "camera": "16",
    "running": "17",
    }

rx_street_number_first = re.compile("^(?P<Num>[0-9]+)[;, -](?P<Street>.*[^0-9])$")
rx_street_number_last = re.compile("^ *(?P<Street>[^0-9].*) *[;, -](?P<Num>[0-9]+)$")


def _convert_wpt_extension(ext_el, wpt_out, ns, link_href,
                           map_category, map_icon, ignore_tags):
    """Convert GARMIN GPX extensions to DaimlerGPXExtensions"""

    gpxx = "{%s}" % (ns["gpxx"],)
    gpxd = "{%s}" % (ns["gpxd"],)

    gxx_wp_ext = ext_el.find(gpxx + "WaypointExtension")
    if gxx_wp_ext is None:
        logging.warning("gpx:wpt has no GARMIN gpxx:WaypointExtension. Ignored")
        return

    out_ext = ET.Element(ext_el.tag)
    out_wptext = ET.Element(gpxd + "WptExtension")

    gpxx_len = len(gpxx)

    category = ""

    for el in gxx_wp_ext:
        if not el.tag.startswith(gpxx):
            logging.debug("Ignored non-gpxx element: %s", el)
            continue
        tname = el.tag[gpxx_len:]
        if tname == "DisplayMode":
            ET.SubElement(out_wptext, gpxd + "Presentation",
                          attrib={"ShowOnMap": "true"})
        elif tname == "Proximity":
            ET.SubElement(out_wptext, gpxd + "Activity",
                          attrib={"Active": "true",
                                  "Level": "warning",
                                  "Unit": "meter",
                                  "Value": str(int(float(el.text)))})
        elif tname == "Categories" and not category:
            for c in el:
                if c.tag == gpxx + "Category":
                    if c.text:
                        category = c.text.strip()
                        if category:
                            break
        elif tname == "Address":
            def get_gpxx_text(tag, defval=""):
                c = el.find(gpxx + tag)
                if c is not None:
                    text = c.text
                    if text:
                        return text.strip()
                return defval

            street = get_gpxx_text("StreetAddress")
            city = get_gpxx_text("City")
            state = get_gpxx_text("State")
            country = get_gpxx_text("Country")
            zipcode = get_gpxx_text("PostalCode")

            housenum = ""
            m = rx_street_number_first.match(street)
            if m:
                housenum = m.group("Num").strip()
                street = m.group("Street").strip()
            else:
                m = rx_street_number_last.match(street)
                if m:
                    housenum = m.group("Num").strip()
                    street = m.group("Street").strip()

            ET.SubElement(out_wptext, gpxd + "Address",
                          attrib={"Street": street.upper(),
                                  "City": city.upper(),
                                  "State": state.upper(),
                                  "Country": country.upper(),
                                  "HouseNo": housenum,
                                  "ZIP": zipcode,
                                  })

        elif tname == "PhoneNumber":
            if el.text:
                phone = el.text.strip()
                if phone:
                    ET.SubElement(out_wptext, gpxd + "Phone",
                                  attrib={"Default": phone})
        else:
            logging.debug("Ignored unsupported element gpxx:%s", tname)

    if len(out_wptext):
        if link_href and not category:
            for match, c in map_category:
                if fnmatch.fnmatch(link_href, match):
                    category = c
                    break

        if category:
            cel = ET.Element(gpxd + "POICategory",
                             attrib={"Cat": category})
            out_wptext.insert(0, cel) # note: order is important

        icon = "1"
        if link_href:
            for match, i in map_icon:
                if fnmatch.fnmatch(link_href, match):
                    icon = i
                    break

        iel = ET.Element(gpxd + "WptIconId",
                         attrib={"IconId": icon})
        out_wptext.insert(0, iel) # note: order is important

        out_ext.append(out_wptext)
        wpt_out.append(out_ext)


def _copy_gpx_tags(el, out):
    """Recursive copy tags in GPX namespace, trims text elements"""
    if not el.tag.startswith("{http://www.topografix.com/GPX/1/1}"):
        return

    out_el = ET.Element(el.tag, attrib=el.attrib)
    if el.text:
        t = el.text.strip()
        if t:
            out_el.text = t

    for c in el:
        _copy_gpx_tags(c, out_el)

    if el.tail:
        t = el.tail.strip()
        if t:
            out_el.tail = t

    out.append(out_el)

def convert_poi(input, output, map_category=(), map_icon=(), ignore_tags=()):
    """Convert PoI from GARMIN to Mercedes-Benz GPX extensions.

    Parameters::

        :param input: input document.
        :type input: string with filename or file-like object.
        :param output: output document.
        :type output: string with filename or file-like object.
        :param map_category: list of link href and associated category.
        :type map_category: list or tuple with (key, value) pairs.
        :param map_icon: list of link href and associated icon.
        :type map_icon: list or tuple with (key, value) pairs.
        :param ignore_tags: list of tags to ignore (may include namespace).
        :type ignore_tags: list or tuple with tags to ignore.

    Mappings (map_icon and map_category) provide tuples of key and
    value, where the key is an fnmatch() expression.

    These are provided to infer the values from ``<link href="LINKHREF">``
    when they are not provided (ie: GARMIN specifies ``<Categories>``)
    """

    # some tools write v2, others v3. Use RegExp to find which
    rx = re.compile("xmlns:([^= ]+) *=['\"]([^'\"]+/GpxExtensions/[^'\"]+)")
    m = None
    for line in input:
        m = rx.search(line)
        if m:
            break

    if m:
        gpxx_ns = m.group(1)
        gpxx_url = m.group(2)
        logging.info("Found XML Namespace %s=%s", gpxx_ns, gpxx_url)
    else:
        gpxx_ns = "gpxx"
        gpxx_url = "http://www.garmin.com/xmlschemas/GpxExtensions/v3"
        logging.warning("No XML Namespace for GpxExtensions! Using %s=%s",
                        gpxx_ns, gpxx_url)

    ns = {
        "xsi": "http://www.w3.org/2001/XMLSchema-instance",
        "gpx": "http://www.topografix.com/GPX/1/1",
        "gpxd": "http://www.daimler.com/DaimlerGPXExtensions/V2.7.2",
        gpxx_ns: gpxx_url
    }
    for k, v in ns.items():
        ET.register_namespace(k, v)


    logging.info("Parsing %s", input)
    input.seek(0)
    indoc = ET.parse(input)
    outroot = ET.Element("{http://www.topografix.com/GPX/1/1}gpx", attrib={
        "version": "1.1",
        "creator": indoc.getroot().get("creator",
                                       "gpx-poi-garmin-to-mercedesbenz"),
        "{http://www.w3.org/2001/XMLSchema-instance}schemaLocation": "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd",
        })

    it = []
    for i in ignore_tags:
        if i.startswith("{"):
            it.append(i)
        else:
            i = i.split(':', 1)
            if len(i) == 1:
                i = ('gpx', i[0])
            it_ns = ns.get(i[0], i[0])
            it_tag = i[1]
            it.append("{%s}%s" % (it_ns, it_tag))

    ignore_tags = it

    logging.info("Converting...")
    for wpt in indoc.findall("gpx:wpt", ns):
        wpt_out = ET.Element(wpt.tag, attrib=wpt.attrib)
        link_href = ""
        for cel in wpt:
            if cel.tag == "{http://www.topografix.com/GPX/1/1}link":
                link_href = cel.get("href", "")

            for i in ignore_tags:
                if cel.tag == i:
                    break
            else:
                if cel.tag == "{http://www.topografix.com/GPX/1/1}extensions":
                    _convert_wpt_extension(cel, wpt_out, ns, link_href,
                                           map_category, map_icon, ignore_tags)
                else:
                    _copy_gpx_tags(cel, wpt_out)

        if len(wpt_out):
            outroot.append(wpt_out)

    if len(outroot) > 30000:
        logging.warning("Writing %d entries (>30000!) to %s", len(outroot), output)
    else:
        logging.info("Writing %d entries to %s", len(outroot), output)
    ET.ElementTree(outroot).write(output, encoding="utf-8", xml_declaration=True)
    logging.info("Finished")


if __name__ == "__main__":
    import argparse, sys, os.path

    outfname = os.path.join(os.path.sep, "PersonalPOI", "PersonalPOIs.gpx")

    parser = argparse.ArgumentParser(
        description=("Convert Point of Interest (PoI) from GARMIN GPX to "
                     "Mercedes-Benz GPX format used in newer COMMAND Online"),
        epilog=("Save output file to SD Card at " + outfname),
        )
    parser.add_argument("input",
                        metavar="GARMIN.GPX",
                        type=argparse.FileType('r'),
                        default=sys.stdin,
                        help="Input file as GARMIN GPX-compatible format")
    parser.add_argument("output",
                        metavar=outfname,
                        type=argparse.FileType('wb'),
                        default=sys.stdout,
                        help="Output file to use with Mercedes Benz COMMAND")
    parser.add_argument("-c", "--link-to-category", action="append",
                        default=[],
                        metavar="LINKHREF:CATEGORY",
                        help=('Map LINKHREF as in <link href="LINKHREF"> to '
                              '<POICategory Cat="CATEGORY">. '
                              'LINKHREF is a fnmatch expression, such as '
                              '"Speedcamera*:Camera" will map all waypoints '
                              'with link href starting with Speedcamera to the '
                              '"Camera" category.'))
    parser.add_argument("-i", "--link-to-icon", action="append",
                        default=[],
                        metavar="LINKHREF:ICON",
                        help=('Map LINKHREF as in <link href="LINKHREF"> to '
                              '<WptIconId IconId="ICON">. '
                              'LINKHREF is a fnmatch expression, such as '
                              '"Speedcamera*:16" will map all waypoints '
                              'with link href starting with Speedcamera to the '
                              'icon index 6 (camera on tripod).'))

    parser.add_argument("-I", "--ignore-tag", action="append",
                        default=[],
                        metavar="namespace:tagname",
                        help=("Specifies tags to ignore, like gpx:link"))

    parser.add_argument("--log", default="WARNING",
                        help=("Log level to use, like DEBUG, WARNING..."))

    args = parser.parse_args()

    loglevel = getattr(logging, args.log.upper(), logging.WARNING)
    logging.basicConfig(level=loglevel)

    map_category = []
    for t in args.link_to_category:
        p = t.split(':', 1)
        if len(p) == 1:
            p.append(p[0])
        map_category.append(tuple(p))

    map_icon = []
    for t in args.link_to_icon:
        try:
            match, icon = t.split(':', 1)
        except ValueError:
            raise SystemExit("ERROR: -i/--link-to-icon needs 'MATCH:ICON', " \
                             "missing ':' in '%s'" % (t,))

        if icon_name_to_id.get(icon.lower()):
            icon = icon_name_to_id[icon]
        else:
            try:
                int(icon, 10)
            except ValueError:
                raise SystemExit("ERROR: -i/--link-to-icon needs 'MATCH:ICON'" \
                                 ", however '%s' is not a known id or number"
                                 % (icon,))

        map_icon.append((match, icon))

    output = convert_poi(args.input, args.output, map_category, map_icon,
                         args.ignore_tag)
